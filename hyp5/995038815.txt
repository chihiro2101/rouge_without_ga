in the simplest implementation , the clerk at the front desk knows only the number of free rooms available , which they only know correctly if all of the students actually use their room while they 've signed up for them and return them when they 're done and of course , a student needs to inform the clerk about releasing their room only after really leaving it , otherwise , there can be an awkward situation when such student is in the process of leaving the room ( they are packing their textbooks , etc when used to control access to a pool of resources , a semaphore tracks only how many resources are free ; it does not keep track of which of the resources are free this includes : requesting a resource and forgetting to release it ; releasing a resource that was never requested ; holding a resource for a long time without needing it ; using a resource without requesting it first ( or after releasing it ) even if all processes follow these rules , multi-resource deadlock may still occur when there are different resources managed by different semaphores and when processes need to use more than one resource at a time , as illustrated by the dining philosophers problem a simple way to understand ( p ) and ( v ) operations is : : decrements the value of semaphore variable by 1 after the increment , if the pre-increment value was negative ( meaning there are processes waiting for a resource ) , it transfers a blocked process from the semaphore 's waiting queue to the ready queue , operations which appear indivisible from the perspective of other processes : function v ( semaphore s , integer i ) : s ← s + i function p ( semaphore s , integer i ) : repeat : if s ≥ i : s ← s − i break however , the remainder of this section refers to semaphores with unary v and p operations , unless otherwise specified if a process performs a p operation on a semaphore that has the value zero , the process is added to the semaphore 's queue and its execution is suspended when another process increments the semaphore by performing a v operation , and there are processes on the queue , one of them is removed from the queue and resumes execution if the implementation does not ensure atomicity of the increment , decrement and comparison operations , then there is a risk of increments or decrements being forgotten , or of the semaphore value becoming negative when s is 0 , any users wishing to log in must wait until and the login request is enqueued onto a fifo queue ; mutual exclusion is used to ensure that requests are enqueued in order they communicate using a queue of maximum size n and are subject to the following conditions : the consumer must wait for the producer to produce something if the queue is empty ; the producer must wait for the consumer to consume something if the queue is full the semaphore solution to the producer–consumer problem tracks the state of the queue with two semaphores : emptycount , the number of empty places in the queue , and fullcount , the number of elements in the queue the binary semaphore usequeue ensures that the integrity of the state of the queue itself is not compromised , for example by two producers attempting to add items to an empty queue simultaneously , thereby corrupting its internal state the producer does the following repeatedly : produce : p ( emptycount ) p ( usequeue ) putitemintoqueue ( item ) v ( usequeue ) v ( fullcount ) the consumer does the following repeatedly consume : p ( fullcount ) p ( usequeue ) item ← getitemfromqueue ( ) v ( usequeue ) v ( emptycount ) below is a substantive example : a single consumer enters its critical section dijkstra subsequently wrote that he intended p to stand for prolaag , short for probeer te verlagen , literally '' try to reduce '' , or to parallel the terms used in the other case , '' try to decrease '' '' ( patch 1/19 ) mutex : introduce simple mutex implementation linux kernel mailing list , 19 december 2005 in algol 68 , the linux kernel , linux kernel hacking howto linuxgrill.com and in some english textbooks , the v and p operations are called , respectively , up and down while a binary semaphore may be colloquially referred to as a mutex , a true mutex has a more specific use-case and definition , in that only the task that locked the mutex is supposed to unlock it this constraint aims to handle some potential problems of using semaphores : priority inversion : if the mutex knows who locked it and is supposed to unlock it , it is possible to promote the priority of that task whenever a higher-priority task starts waiting on the mutex 