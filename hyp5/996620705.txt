in this case , the collision detection algorithm need not be aware of the myriad of physical variables ; a simple list of physical bodies is fed to the algorithm , and the program returns a list of intersecting bodies in all cases , resting contact requires special treatment : if two objects collide ( a posteriori ) or slide ( a priori ) and their relative motion is below a threshold , friction becomes stiction and both objects are arranged in the same branch of the scene graph in other words , physical simulators usually function one of two ways , where the collision is detected a posteriori ( after the collision occurs ) or a priori ( before the collision occurs ) at each simulation step , a list of all intersecting bodies is created , and the positions and trajectories of these objects are '' fixed '' to account for the collision despite this resource limit , and the use of relatively primitive collision detection algorithms , programmers have been able to create believable , if inexact , systems for use in games some objects are in resting contact , that is , in collision , but neither bouncing off , nor interpenetrating , such as a vase resting on a table in addition to the a posteriori and a priori distinction , almost all modern collision detection algorithms are broken into a hierarchy of algorithms in many cases for video games , approximating the characters by a point is sufficient for the purpose of collision detection with the environment in other instances , the '' fixing '' that posteriori algorithms require is n't implemented correctly , resulting in bugs that can trap characters in walls or allow them to pass through them and fall an endless void where there may or may not be a deadly bottomless pit , sometimes referred to as '' black hell '' , '' blue hell '' , or '' green hell '' , depending on the predominant color triangular number will , of course , work , but is too inefficient to be used when the number of objects is at all large this method is called a posteriori because it typically misses the actual instant of collision , and only catches the collision after it has actually happened in the a priori methods , there is a collision detection algorithm which will be able to predict very precisely the trajectories of the physical bodies some simulators estimate the time of collision by linear interpolation , roll back the simulation , and calculate the collision by the more abstract methods of conservation laws it is often a rectangle ( in 2d games ) or cuboid ( in 3d ) that is attached to and follows a point on a visible object ( such as a model or a sprite ) at the coarse level of collision detection , the objective is to find pairs of objects which might potentially intersect however , in all but the simplest cases , the problem of determining ahead of time when two bodies will collide ( given some initial data ) has no closed form solutionâ€”a numerical root finder is usually involved in other cases , simply tiling the screen and binding each sprite into the tiles it overlaps provides sufficient pruning , and for pairwise checks , bounding rectangles or circles called hitboxes are used and deemed sufficiently accurate algorithms have been designed so that the calculations done in a preceding time step can be reused in the current time step , resulting in faster completion of the calculation moreover , if the discrete step is too large , the collision could go undetected , resulting in an object which passes through another if it is sufficiently fast or small an initial description of the situation would be given , with a very precise physical description of the billiard table and balls , as well as initial positions of all the balls 