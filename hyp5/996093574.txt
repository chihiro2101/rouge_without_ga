command manager , undo manager , scheduler , queue , dispatcher , invoker : an object that puts command/event objects on an undo stack or redo stack , or that holds on to command/event objects until other objects are ready to act on them , or that routes the command/event objects to the appropriate receiver/target object or handler code the command design pattern is one of the twenty-three well-known design patterns that describe how to solve recurring design problems to design flexible and reusable object-oriented software , that is , objects that are easier to implement , change , test , and reuse instead , invoker refers to the command interface to perform a request ( command.execute ( ) ) , which makes the invoker independent of how the request is performed command object , routed event arguments , event object : the object that is passed from the source to the command/action object , to the target object to the code that does the work ; parallel processing : where the commands are written as tasks to a shared resource and executed by many threads in parallel ( possibly on remote machines ; this variant is often referred to as the master/worker pattern ) ; progress bars : suppose a program has a sequence of commands that it executes in order typically these objects implement a common interface such as that allows the thread pool to execute the command even though the thread pool class itself was written without any knowledge of the specific tasks for which it would be used for example , move up , move up may refer to a single ( move up ) command that should be executed twice , or it may refer to two commands , each of which happens to do the same thing ( move up ) instead , invoking the command object 's execute command results in a so-called executed routed event that during the event 's tunneling or bubbling may encounter a so-called binding object that identifies the target and the application code , which is executed at that point for example , if the receiver object is a cursor and the method is called moveup , then one would expect that the cursor is the target of the moveup action implementing ( hard-wiring ) a request directly into a class is inflexible because it couples the class to a particular request at compile-time , which makes it impossible to specify a request at run-time ; macro recording : if all user actions are represented by command objects , a program can record a sequence of actions simply by keeping a list of the command objects as they are executed for example , to undo a delete selection command , the object may contain a copy of the deleted text so that it can be re-inserted , if the delete selection command must be undone however , in microsoft 's windows presentation foundation a command is considered to have been executed when the command 's execute method has been invoked , but that does not necessarily mean that the application code has run for example , if two database tables that refer to each other must be updated , and the second update fails , the transaction can be rolled back , so that the first table does not now contain an invalid reference a benefit of this particular implementation of the command pattern is that the switch can be used with any device , not just a light note that using a separate object for each invocation of a command is also an example of the chain of responsibility pattern this is the result of ambiguity , the use of synonyms , and implementations that may obscure the original pattern by going well beyond it on the other hand , if the code is defined by the command object itself , the target object will be a different object entirely 