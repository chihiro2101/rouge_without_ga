an alternative way to keep the number of updates bound relatively to the container size would be to use a kind of handle mechanism , that is a collection of indirect pointers to the container 's elements that must be updated with the container , and let the iterators point to these handles instead of directly to the data elements this assertion must however be taken with a grain of salt , because more often than not , for efficiency reasons , the iterator implementation is so tightly bound to the container that it does preclude modification of the underlying container without invalidating itself implicit iterators are often manifested by a '' foreach '' statement ( or equivalent ) , such as in the following python example : for value in iterable : print ( value ) in python , an iterable is an object which can be converted to an iterator , which is then iterated through during the for loop ; this is done implicitly although indexing may also be used with some object-oriented containers , the use of iterators may have some advantages : counting loops are not suitable to all data structures , in particular to data structures with no or slow random access , like lists or trees for containers that may move around their data in memory , the only way to not invalidate the iterator is , for the container , to somehow keep track of all the currently alive iterators and update them on the fly some object-oriented languages such as c , c++ ( later versions ) , delphi ( later versions ) , go , java ( later versions ) , lua , perl , python , ruby provide an intrinsic way of iterating through the elements of a container object without the introduction of an explicit iterator object an example of a python generator returning an iterator for the fibonacci numbers using python 's yield statement follows : def fibonacci ( limit ) : a , b 0 , 1 for _ in range ( limit ) : yield a a , b b , a + b for number in fibonacci ( 100 ) : the generator constructs an iterator print ( number ) or other times they may be created by the collection object itself , as in this ruby example : iterable.each do value puts value end this iteration style is sometimes called '' internal iteration '' because its code fully executes within the context of the iterable object ( that controls all aspects of iteration ) , and the programmer only provides the operation to execute at each step ( using an anonymous function ) iteratee , in which , instead of the developer calling the iterator repeatedly to get new values , the iteratee is called repeatedly to process new chunks of data - an example of inversion of control an external iterator may be thought of as a type of pointer that has two primary operations : referencing one particular element in the object collection ( called element access ) , and modifying itself so it points to the next element ( called element traversal ) the primary purpose of an iterator is to allow a user to process every element of a container while isolating the user from the internal structure of the container 