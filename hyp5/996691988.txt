a bit copying machine , called bitbitjump , copies one bit in memory and passes the execution unconditionally to the address specified by one of the operands of the instruction another machine , called the toga computer , inverts a bit and passes the execution conditionally depending on the result of inversion the unique instruction is toga ( a , b ) which stands for toggle a and branch to b if the result of the toggle operation is true for example , in an oisc using a single memory-to-memory copy instruction , this is done by triggering ports that perform arithmetic and instruction pointer jumps when written to common choices for the single instruction are : subtract and branch if less than or equal to zero subtract and branch if negative arithmetic machine reverse subtract and skip if borrow move ( used as part of a transport triggered architecture ) subtract and branch if non zero ( sbnz a , b , c , destination ) cryptoleq ( heterogeneous encrypted and unencrypted computation ) only one of these instructions is used in a given implementation hence , there is no need for an opcode to identify which instruction to execute ; the choice of instruction is inherent in the design of the machine , and an oisc is typically named after the instruction it uses ( e.g for example , one variation known as dln ( decrement and jump if not zero ) has only two operands and uses decrement as the base operation the sbnz a , b , c , d instruction ( '' subtract and branch if not equal to zero '' ) subtracts the contents at address a from the contents at address b , stores the result at address c , and then , if the result is not 0 , transfers control to address d ( if the result is equal to zero , execution proceeds to the next instruction in sequence ) the instruction ( '' subtract and branch if less than or equal to zero '' ) subtracts the contents at address from the contents at address , stores the result at address , and then , if the result is not positive , transfers control to address ( if the result is positive , execution proceeds to the next instruction in sequence ) the result is stored in both the accumulator and the memory location , and the second operand specifies the branch address : subleq2 a , b ; mema mema - accum ; accum mema ; if ( mema ≤ 0 ) goto b although this uses only two ( instead of three ) operands per instruction , correspondingly more instructions are then needed to effect various logical operations , the following instructions result in the content at location being added to the content at location : ; : subleq a , z subleq z , b subleq z , z the first instruction subtracts the content at location from the content at location ( which is 0 ) and stores the result ( which is the negative of the content at in location the following program ( written in pseudocode ) emulates the execution of a -based oisc : int memory , program_counter , a , b , c program_counter 0 while ( program_counter > 0 ) : a memoryprogram_counter b memoryprogram_counter+1 c memoryprogram_counter+2 if ( a 0 ) : program_counter + 3 else : program_counter c this program assumes that is indexed by nonnegative integers the instruction ( '' subtract and branch if negative '' ) , also called , is defined similarly to : subneg a , b , c ; memb memb - mema ; if ( memb conditional branching can be suppressed by setting the third operand equal to the address of the next instruction in sequence the machine has an infinite abacus , an infinite number of counters ( pebbles , tally sticks ) initially at a special location s pseudocode : command x , y , z , t ; if ( memy after giving a few programs : multiplication , gcd , computing the n-th prime number , representation in base b of an arbitrary number , sorting in order of magnitude , melzac shows explicitly how to simulate an arbitrary turing machine on his arithmetic machine a proof of which was given by lambek on an equivalent two instruction machine : x+ ( increment x ) and x− else t ( decrement x if it not empty , else jump to t ) in a reverse subtract and skip if borrow ( rssb ) instruction , the accumulator is subtracted from the memory location and the next instruction is skipped if there was a borrow ( memory location was smaller than the accumulator ) a commercial transport triggered architecture microcontroller has been produced called maxq , which hides the apparent inconvenience of an oisc by using a '' transfer map '' that represents all possible destinations for the move instructions cryptoleq is a language consisting of one eponymous instruction , is capable of performing general-purpose computation on encrypted programs and is a close relative to subleq 