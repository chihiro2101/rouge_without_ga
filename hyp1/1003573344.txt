a symbolic link contains a text string that is automatically interpreted and followed by the operating system as a path to another file or directory if a symbolic link points to a target , and sometime later that target is moved , renamed or deleted , the symbolic link is not automatically updated or deleted , but continues to exist and still points to the old target , now a non-existing location or file hard links do not link paths on different volumes or file system , whereas symbolic links may point to any file or directory irrespective of the volumes on which the link and target reside symbolic links operate transparently for many operations : programs that read or write to files named by a symbolic link will behave as if operating directly on the target file however , they have the effect of changing an otherwise hierarchic filesystem from a tree into a directed graph , which can have consequences for such simple operations as determining the current directory of a process some shells heuristically try to uphold the illusion of a tree-shaped hierarchy , but when they do , this causes them to produce different results from other programs that manipulate pathnames without such heuristic , relying on the operating system instead the following command creates a symbolic link at the command-line interface ( shell ) : ln -s target_path link_path target_path is the relative or absolute path to which the symbolic link should point the posix directory listing application , ls , denotes symbolic links with an arrow after the name , pointing to the name of the target file ( see following example ) , when the long directory list is requested ( -l option ) the file contained the textual reference to the link 's target , and the file mode bits indicated that the type of the file is a symbolic link although storing the link value inside the inode saves a disk block and a disk read , the operating system still needs to parse the path name in the link , which always requires reading additional inodes and generally requires reading other , and potentially many , directories , processing both the list of files and the inodes of each of them until it finds a match with the link 's path components some operating systems , such as freebsd , offer the ability to modify file permissions and filesystem attributes of a symbolic link , through lchmod and lchflags system calls respectively it was included with windows xp , but was only enabled by default for kernel mode programs ; windows vista and later versions of windows enabled support for symbolic links to user mode applications , as well , and supplied the command line utility mklink for creating them createsymboliclink function , msdn library , win32 and com development windows 7 and vista support a maximum of 31 reparse points ( and therefore symbolic links ) for a given path ( i.e additionally , ntfs symbolic links to files are distinct from ntfs symbolic links to directories and therefore can not be used interchangeably , unlike on posix where the same symbolic link can refer to either files or directories in windows vista and later , when the working directory path ends with a symbolic link , the current parent path reference , , will refer to the parent directory of the symbolic link rather than that of its target this behaviour is also found at the shell level in at least some posix systems , including linux , but never in accessing files and directories through operating system calls shortcuts , which are supported by the graphical file browsers of some operating systems , may resemble symbolic links but differ in a number of important ways any software program , upon accessing a symbolic link , will see the target instead , whether the program is aware of symbolic links or not another difference are the capabilities of the mechanism : microsoft windows shortcuts normally refer to a destination by an absolute path ( starting from the root directory ) , whereas posix symbolic links can refer to destinations via either an absolute or a relative path the latter is useful if both the location and destination of the symbolic link share a common path prefix , but that prefix is not yet known when the symbolic link is created ( e.g internally the dos.library returns an error code indicating that a target is a soft link if you try to perform actions on it that are only legal for a file , and applications that wish to follow the symbolic link then needs to explicitly make a call to follow the link and retry the operation symbolic links may be implemented in a context-dependent or variable fashion , such that the link points to varying targets depending on a configuration parameter , run-time parameter , or other instantaneous condition q & a : the difference between hard and soft links as applied to linux junction : maintain ntfs junction points ( for windows 2000 and above ) fsutil hardlink : microsoft technet page on using the command-line tool fsutil to create hardlinks ( for windows 2000 and above ) link shell extension : windows explorer context menu , overlay icons and property sheet handler to maintain hardlinks , ntfs junction points , symbolic links etc symbolic drivers for windows xp : file system drivers to enables symbolic links for windows xp ( also mirrored on link shell extension site ) 