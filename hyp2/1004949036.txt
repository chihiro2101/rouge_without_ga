if the user has magnified a document so that only part of it is visible on his computer screen , and then scrolls in it , it is useful to use a bounding box ( or in this case , a bounding rectangle scheme ) to quickly determine which scene graph elements are visible and thus actually need to be drawn a traversal generally consists of starting at some arbitrary node ( often the root of the scene graph ) , applying the operation ( s ) ( often the updating and rendering operations are applied one after the other ) , and recursively moving down the scene graph ( tree ) to the child nodes , until a leaf node is reached although shapes themselves ( particularly paths ) can be decomposed further into nodes such as spline nodes , it is practical to think of the scene graph as composed of shapes rather than going to a lower level of representation in our example above , each knight is a separate scene node , but the graphical representation of the knight ( made up of a 3d mesh , textures , materials and shaders ) is instanced in particular , it is bad to have the scene graph contained within the spatial partitioning system , as the scene graph is better thought of as the grander system to the spatial partitioning the operation can be realised as a class that is passed to the current node ; it then queries the node 's type using rtti and looks up the correct operation in an array of callbacks or functors it is an iso-ratified standard that provides a system for the storage , retrieval and playback of real-time graphics content embedded in applications , all within an open architecture to support a wide array of domains and user scenarios this means that only a single copy of the data is kept , which is then referenced by any 'knight ' nodes in the scene graph for example , in a render operation , a transformation group node would accumulate its transformation by matrix multiplication , vector displacement , quaternions or euler angles at the bottom of the hierarchy , the size of the volume is just large enough to encompass a single object tightly ( or possibly even some smaller fraction of an object in high resolution bvhs ) the simplest form of scene graph uses an array or linked list data structure , and displaying its shapes is simply a matter of linearly iterating the nodes one by one a scene graph can easily be adapted to include/become a bvh â€“ if each node has a volume associated or there is a purpose-built '' bound node '' added in at convenient location in the hierarchy bsp trees , however , take a very long time to compute from design scene graphs , and must be recomputed if the design scene graph changes , so the levels tend to remain static , and dynamic characters are n't generally considered in the spatial partitioning scheme in object-oriented languages such as c++ , this can easily be achieved by virtual functions , where each represents an operation that can be performed on a node in vector-based graphics editing , each leaf node in a scene graph represents some atomic unit of the document , usually a shape such as an ellipse or bezier path a raytracer , for example , will take a scene description of a 3d model and build an internal representation that breaks up its individual parts into bounding boxes ( also called bounding slabs ) in 3d systems , which often employ depth buffers , it is more efficient to draw the closest objects first , since farther objects often need only be depth-tested instead of actually rendered , because they are occluded by nearer objects in such applications , nodes in a scene graph ( generally ) represent entities or objects in the scene very large drawings , or scene graphs that are generated solely at runtime ( as happens in ray tracing rendering programs ) , require defining of group nodes in a more automated fashion at the root of the tree is a volume that encompasses all the volumes in the tree ( the whole scene ) 